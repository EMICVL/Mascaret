#!/usr/bin/env python# -*- coding: iso-8859-1 -*-## LI2/ENIB - ProjectBuilder##----------------------------------------------------------------------------## file        : ProjectBuilder.py## author(s)   : J. Soler##----------------------------------------------------------------------------## Copyright (C) 2002-2010  LI2/ENIB##   Laboratoire d'Ingenierie Informatique (LI2)##   Ecole Nationale d'Ingenieurs de Brest (ENIB)##   CS 73862 - 29238 BREST Cedex 3 - France##   Tel: +33(0)298 05 89 89, Fax: +33(0)298 05 89 79, e-mail: li2@enib.fr#### This software package is free software; you can redistribute it and/or## modify it under the terms of the GNU Lesser General Public License as## published by the Free Software Foundation; either version 2.1 of the## License, or (at your option) any later version.## This software package is distributed in the hope that it will be useful,## but WITHOUT ANY WARRANTY; without even the implied warranty of## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser## General Public License (file LICENSE-LGPL) for more details.##----------------------------------------------------------------------------import TransProgConfigimport sysimport osimport uuidclass ProjectBuilderTool(object):  """ProjectBuilderTool: a specilization of the TransProg tool which provide VS2010 project build capabilities."""  def __init__(self,tool):    if tool.sysName() != "Windows":      print "VS2010 project can only be generated on Windows platform"      exit(-1)    self.tool=tool  def run(self):    programs=self.tool._libraries+self.tool._plugins+self.tool._programs    for prog in programs:      self.generateVS2010Project(prog)  def generateVS2010Project(self,prog):    """Generates VS2010 project file"""    projName=os.path.splitext(prog.name)[0]    f=file(projName+".vcxproj",'w')    f.write('<?xml version="1.0" encoding="utf-8"?>\n')    f.write('<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">\n')    f.write('  <ItemGroup Label="ProjectConfigurations">\n')    f.write('    <ProjectConfiguration Include="Debug|Win32">\n')    f.write('      <Configuration>Debug</Configuration>\n')    f.write('      <Platform>Win32</Platform>\n')    f.write('    </ProjectConfiguration>\n')    f.write('    <ProjectConfiguration Include="Release|Win32">\n')    f.write('      <Configuration>Release</Configuration>\n')    f.write('      <Platform>Win32</Platform>\n')    f.write('    </ProjectConfiguration>\n')    f.write('  </ItemGroup>\n')    f.write('  <PropertyGroup Label="Globals">\n')    f.write('    <ProjectGuid>{%s}</ProjectGuid>\n' % (uuid.uuid1()))    f.write('    <ProjectName>%s</ProjectName>\n' % (projName))    f.write('  </PropertyGroup>\n')    f.write('  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />\n')    type='Application'    if prog.kind=='lib' or prog.kind=='plug':      type='DynamicLibrary'    f.write('  <PropertyGroup Condition="\'$(Configuration)|$(Platform)\'==\'Debug|Win32\'" Label="Configuration">\n')    f.write('    <ConfigurationType>%s</ConfigurationType>\n' % (type))    f.write('  </PropertyGroup>\n')    f.write('  <PropertyGroup Condition="\'$(Configuration)|$(Platform)\'==\'Release|Win32\'" Label="Configuration">\n')    f.write('    <ConfigurationType>%s</ConfigurationType>\n' % (type))    f.write('  </PropertyGroup>\n')    f.write('  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />\n')    f.write('  <PropertyGroup Condition="\'$(Configuration)|$(Platform)\'==\'Debug|Win32\'">\n')    f.write('    <OutDir>$(ProjectDir)\</OutDir>\n')    f.write('  </PropertyGroup>\n')    self.writeCompilerOptions(f,prog,True)    f.write('  <PropertyGroup Condition="\'$(Configuration)|$(Platform)\'==\'Release|Win32\'">\n')    f.write('    <OutDir>$(ProjectDir)\</OutDir>\n')    f.write('  </PropertyGroup>\n')    self.writeCompilerOptions(f,prog,False)    f.write('  <ItemGroup>\n')        includes=[]    for i in prog.sources:      f.write('    <ClCompile Include="%s">\n' % i)      objFile=os.path.splitext(i)[0]+".obj"      f.write('      <ObjectFileName>$(IntDir)%s</ObjectFileName>\n' % objFile)      f.write('    </ClCompile>\n')            includes+=[inc for inc in self.collectProjectHeaders(i,prog.settings) if includes.count(inc) == 0]    f.write('  </ItemGroup>\n')    f.write('  <ItemGroup>\n')    for i in includes:      f.write('    <ClInclude Include="%s" />\n' % i)    f.write('  </ItemGroup>\n')    f.write('  <ItemGroup>\n')    for lib in prog.settings["LIBS"]:      if self.isProjectDependancy(lib,prog.settings):        libPath=self.tool.findLibrary(lib,prog.settings)        self.writeProjectDependancy(f,lib,os.path.dirname(libPath))    f.write('  </ItemGroup>\n')    f.write('  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />\n')    f.write('</Project>\n')    self.generateVS2010FiltersFile(projName,prog.sources,includes)  def isProjectDependancy(self,lib,settings):    libPath=self.tool.findLibrary(lib,settings)    if libPath == None:      return False    return os.path.exists(os.path.join(os.path.dirname(libPath),lib)+".vcxproj")	  def writeProjectDependancy(self,f,lib,libPath):    import xml.dom    import xml.dom.minidom    doc = xml.dom.minidom.parse(os.path.join(libPath,lib)+".vcxproj")    groups=doc.documentElement.getElementsByTagName('PropertyGroup')    for g in groups:      if g.getAttribute('Label') == 'Globals':        guid=g.getElementsByTagName('ProjectGuid')[0].firstChild.data        f.write("    <ProjectReference Include=\"%s\">\n" % (os.path.relpath(os.path.join(libPath,lib))+".vcxproj"))        f.write("      <Project>%s</Project>\n" % (guid))        f.write("    </ProjectReference>\n")  def writeCompilerOptions(self,f,prog,debug):    """Writes compiler options in VS 2010 project file"""    if debug:      f.write('  <ItemDefinitionGroup Condition="\'$(Configuration)|$(Platform)\'==\'Debug|Win32\'">\n')    else:      f.write('  <ItemDefinitionGroup Condition="\'$(Configuration)|$(Platform)\'==\'Release|Win32\'">\n')    f.write('    <ClCompile>\n')    f.write('      <PrecompiledHeader>NotUsing</PrecompiledHeader>\n')    ccFlags=prog.settings['CCFLAGS']    if debug:      ccFlags+=prog.settings['DBGFLAGS']    else:      ccFlags+=prog.settings['OPTFLAGS']    if ccFlags.count("/W4") > 0:      f.write('      <WarningLevel>Level4</WarningLevel>\n')    elif ccFlags.count("/W3") > 0:      f.write('      <WarningLevel>Level3</WarningLevel>\n')    elif ccFlags.count("/W2") > 0:      f.write('      <WarningLevel>Level2</WarningLevel>\n')    elif ccFlags.count("/W1") > 0:      f.write('      <WarningLevel>Level1</WarningLevel>\n')    elif ccFlags.count("/W0") > 0:      f.write('      <WarningLevel>Level0</WarningLevel>\n')    else:      f.write('      <WarningLevel>Level2</WarningLevel>\n')    if debug:      f.write('      <Optimization>Disabled</Optimization>\n')    defines=""    for d in prog.settings['DEFINES']:      defines+=d      if prog.settings['DEFINES'][d] != None:        defines+="="+str(prog.settings['DEFINES'][d])      defines+=";"    for d in ccFlags:      if d.startswith("/D") or d.startswith("-D"):         defines+=d[2:]+";"    f.write('      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%%(PreprocessorDefinitions);%s</PreprocessorDefinitions>\n' % (defines))    incDirs=""    for d in prog.settings['INCDIRS']:      incDirs+=os.path.normpath(d)+";"    for d in ccFlags:      if d.startswith("/I") or d.startswith("-I"):         incDirs+=os.path.normpath(d[2:])+";"    f.write('      <AdditionalIncludeDirectories>%%(AdditionalIncludeDirectories);%s</AdditionalIncludeDirectories>\n' % (incDirs))        if ccFlags.count("/TP") > 0:      f.write('      <CompileAs>CompileAsCpp</CompileAs>\n')    elif ccFlags.count("/TC") > 0:      f.write('      <CompileAs></CompileAs>\n')    disableWarnings="";    for flag in ccFlags:      if flag.startswith('/wd'):        disableWarnings+=flag[3:]+";"    if disableWarnings != "":      f.write('      <DisableSpecificWarnings>%s%%(DisableSpecificWarnings)</DisableSpecificWarnings>\n' % (disableWarnings))    if ccFlags.count("/MDd") > 0:      f.write('      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>\n')    elif ccFlags.count("/MD") > 0:      f.write('      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\n')    elif ccFlags.count("/MTd") > 0:      f.write('      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n')    elif ccFlags.count("/MT") > 0:      f.write('      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n')    if ccFlags.count("/MP") > 0:      f.write('      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n')    f.write('    </ClCompile>\n')    f.write('    <Link>\n')    f.write('      <SubSystem>Console</SubSystem>\n')    if(debug):      f.write('      <GenerateDebugInformation>true</GenerateDebugInformation>\n')    else:      f.write('      <GenerateDebugInformation>false</GenerateDebugInformation>\n')        libDirs=""    for d in prog.settings['LIBDIRS']:      libDirs+=os.path.normpath(d)+";"    for d in prog.settings['LDFLAGS']:      if d.startswith("/LIBPATH:"):         defines+=os.path.normpath(d[9:])+";"    f.write('      <AdditionalLibraryDirectories>%%(AdditionalLibraryDirectories);%s</AdditionalLibraryDirectories>\n' % (libDirs))    libs=""    for l in prog.settings['LIBS']:      if not self.isProjectDependancy(l,prog.settings):        lib=self.tool.findLibrary(l,prog.settings,debug)        if lib != None:          lib=os.path.splitext(os.path.basename(lib))[0]        else:          lib=l;        libs+=lib+".lib;"    f.write('      <AdditionalDependencies>%%(AdditionalDependencies);%s</AdditionalDependencies>\n' % (libs))    f.write('    </Link>\n')    f.write('  </ItemDefinitionGroup>\n')    def generateVS2010FiltersFile(self,projName,sources,includes):    """Generates filter file"""    filters=[]    f=file(projName+".vcxproj.filters",'w')    f.write('<?xml version="1.0" encoding="utf-8"?>\n')    f.write('<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">\n')    f.write('  <ItemGroup>\n')    for s in sources:      filter=os.path.dirname(s)      if filter.startswith('src') or filter.startswith('sources'):        index=filter.find('\\')        if index != -1:          filter=filter[index+1:]      if not filter or filter == "" or filter == "src" or filter == "sources":        continue      f.write('    <ClCompile Include="%s">\n' % (s))      f.write('      <Filter>%s</Filter>\n' % (filter))      startIndex=0      while startIndex != -1:        startIndex=filter.find('\\',startIndex)        if startIndex == -1:          subfilter=filter        else:          subfilter=filter[0:startIndex]          startIndex=startIndex+1;        if filters.count(subfilter) == 0:          filters+=[subfilter]      f.write('    </ClCompile>\n')    f.write('  </ItemGroup>\n')    f.write('  <ItemGroup>\n')    for s in includes:      filter=os.path.dirname(s)      if filter.startswith('include'):        index=filter.find('\\')        if index != -1:          filter=filter[index+1:]      if not filter or filter == "" or filter == "include":        continue      f.write('    <ClInclude Include="%s">\n' % (s))      f.write('      <Filter>%s</Filter>\n' % (filter))      startIndex=0      while startIndex != -1:        startIndex=filter.find('\\',startIndex)        if startIndex == -1:          subfilter=filter        else:          subfilter=filter[0:startIndex]          startIndex=startIndex+1;        if filters.count(subfilter) == 0:          filters+=[subfilter]      f.write('    </ClInclude>\n')    f.write('  </ItemGroup>\n')    f.write('  <ItemGroup>\n')    for filter in filters:      f.write('    <Filter Include="%s">\n' % (filter))      f.write('      <UniqueIdentifier>{%s}</UniqueIdentifier>\n' % (uuid.uuid4()))      f.write('    </Filter>\n')    f.write('  </ItemGroup>\n')    f.write('</Project>\n')      def collectProjectHeaders(self,source,settings):    """Collects projects header file.    Included files whose include dir is not absolute and not at a higher path level are considered like in the project."""    includes=[]    try:      f=file(source,'r')    except:      return includes    for l in f:       m=self.tool._stdIncRE.match(l)       if not m:         m=self.tool._locIncRE.match(l)       if m: # incdirs --> (stddirs) --> localdir         inc=m.string[m.start(1):m.end(1)]         for d in settings['INCDIRS']:           if not os.path.isabs(d) and not d.startswith('..'):             header=os.path.normpath(os.path.join(d,inc))             if os.path.exists(header):               if includes.count(header) == 0:                 includes+=[header]    return includes      